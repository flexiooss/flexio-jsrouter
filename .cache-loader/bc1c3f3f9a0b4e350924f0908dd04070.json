{"remainingRequest":"/mnt/DATA/DEV/JS/flexio-jsrouter/node_modules/babel-loader/lib/index.js??ref--6!/mnt/DATA/DEV/JS/flexio-jsrouter/node_modules/eslint-loader/index.js??ref--5!/mnt/DATA/DEV/JS/flexio-jshelpers/src/types/Enumify.js","dependencies":[{"path":"/mnt/DATA/DEV/JS/flexio-jshelpers/src/types/Enumify.js","mtime":1547723597462},{"path":"/mnt/DATA/DEV/JS/flexio-jsrouter/node_modules/cache-loader/dist/cjs.js","mtime":1549958118441},{"path":"/mnt/DATA/DEV/JS/flexio-jsrouter/node_modules/babel-loader/lib/index.js","mtime":1548754057753},{"path":"/mnt/DATA/DEV/JS/flexio-jsrouter/node_modules/eslint-loader/index.js","mtime":1549372049588}],"contextDependencies":[],"result":["var INITIALIZED = Symbol();\n/**\n * This is an abstract class that is not intended to be\n * used directly. Extend it to turn your class into an enum\n * (initialization is performed via `MyClass.initEnum()`).\n */\n\nexport class FlexEnum {\n  /**\n   * `initEnum()` closes the class. Then calling this constructor\n   * throws an exception.\n   *\n   * If your subclass has a constructor then you can control\n   * what properties are added to `this` via the argument you\n   * pass to `super()`. No arguments are fine, too.\n   */\n  constructor() {\n    var instanceProperties = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;\n\n    // new.target would be better than this.constructor,\n    // but isn’t supported by Babel\n    if ({}.hasOwnProperty.call(this.constructor, INITIALIZED)) {\n      throw new Error('Enum classes can’t be instantiated');\n    }\n\n    if (typeof instanceProperties === 'object' && instanceProperties !== null) {\n      copyProperties(this, instanceProperties);\n    }\n  }\n  /**\n   * Set up the enum, close the class.\n   *\n   * @param arg Either an object whose properties provide the names\n   * and values (which must be mutable objects) of the enum constants.\n   * Or an Array whose elements are used as the names of the enum constants\n   * The values are create by instantiating the current class.\n   */\n\n\n  static initEnum(arg) {\n    Object.defineProperty(this, 'enumValues', {\n      value: [],\n      configurable: false,\n      writable: false,\n      enumerable: true\n    });\n\n    if (Array.isArray(arg)) {\n      this._enumValuesFromArray(arg);\n    } else {\n      this._enumValuesFromObject(arg);\n    }\n\n    Object.freeze(this.enumValues);\n    this[INITIALIZED] = true;\n    return this;\n  }\n\n  static _enumValuesFromArray(arr) {\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = arr[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var key = _step.value;\n\n        this._pushEnumValue(new this(), key);\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return != null) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n  }\n\n  static _enumValuesFromObject(obj) {\n    var _arr = Object.keys(obj);\n\n    for (var _i = 0; _i < _arr.length; _i++) {\n      var key = _arr[_i];\n      var value = new this(obj[key]);\n\n      this._pushEnumValue(value, key);\n    }\n  }\n\n  static _pushEnumValue(enumValue, name) {\n    enumValue.name = name;\n    enumValue.ordinal = this.enumValues.length;\n    Object.defineProperty(this, name, {\n      value: enumValue,\n      configurable: false,\n      writable: false,\n      enumerable: true\n    });\n    this.enumValues.push(enumValue);\n  }\n  /**\n   * Given the name of an enum constant, return its value.\n   */\n\n\n  static enumValueOf(name) {\n    return this.enumValues.find(x => x.name === name);\n  }\n  /**\n   * Make enum classes iterable\n   */\n\n\n  static [Symbol.iterator]() {\n    return this.enumValues[Symbol.iterator]();\n  }\n  /**\n   * Default `toString()` method for enum constant.\n   */\n\n\n  toString() {\n    return `${this.constructor.name}.${this.name}`;\n  }\n\n}\nexport function copyProperties(target, source) {\n  // Ideally, we’d use Reflect.ownKeys() here,\n  // but I don’t want to depend on a polyfill\n  var _iteratorNormalCompletion2 = true;\n  var _didIteratorError2 = false;\n  var _iteratorError2 = undefined;\n\n  try {\n    for (var _iterator2 = Object.getOwnPropertyNames(source)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n      var key = _step2.value;\n      var desc = Object.getOwnPropertyDescriptor(source, key);\n      Object.defineProperty(target, key, desc);\n    }\n  } catch (err) {\n    _didIteratorError2 = true;\n    _iteratorError2 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n        _iterator2.return();\n      }\n    } finally {\n      if (_didIteratorError2) {\n        throw _iteratorError2;\n      }\n    }\n  }\n\n  return target;\n}",{"version":3,"sources":["/mnt/DATA/DEV/JS/flexio-jshelpers/src/types/Enumify.js"],"names":["INITIALIZED","Symbol","FlexEnum","constructor","instanceProperties","undefined","hasOwnProperty","call","Error","copyProperties","initEnum","arg","Object","defineProperty","value","configurable","writable","enumerable","Array","isArray","_enumValuesFromArray","_enumValuesFromObject","freeze","enumValues","arr","key","_pushEnumValue","obj","keys","enumValue","name","ordinal","length","push","enumValueOf","find","x","iterator","toString","target","source","getOwnPropertyNames","desc","getOwnPropertyDescriptor"],"mappings":"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","sourcesContent":["const INITIALIZED = Symbol();\n\n/**\n * This is an abstract class that is not intended to be\n * used directly. Extend it to turn your class into an enum\n * (initialization is performed via `MyClass.initEnum()`).\n */\nexport class FlexEnum {\n    /**\n     * `initEnum()` closes the class. Then calling this constructor\n     * throws an exception.\n     *\n     * If your subclass has a constructor then you can control\n     * what properties are added to `this` via the argument you\n     * pass to `super()`. No arguments are fine, too.\n     */\n    constructor(instanceProperties = undefined) {\n        // new.target would be better than this.constructor,\n        // but isn’t supported by Babel\n        if ({}.hasOwnProperty.call(this.constructor, INITIALIZED)) {\n            throw new Error('Enum classes can’t be instantiated');\n        }\n        if (typeof instanceProperties === 'object' && instanceProperties !== null) {\n            copyProperties(this, instanceProperties);\n        }\n    }\n    /**\n     * Set up the enum, close the class.\n     *\n     * @param arg Either an object whose properties provide the names\n     * and values (which must be mutable objects) of the enum constants.\n     * Or an Array whose elements are used as the names of the enum constants\n     * The values are create by instantiating the current class.\n     */\n    static initEnum(arg) {\n        Object.defineProperty(this, 'enumValues', {\n            value: [],\n            configurable: false,\n            writable: false,\n            enumerable: true,\n        });\n        if (Array.isArray(arg)) {\n            this._enumValuesFromArray(arg);\n        } else {\n            this._enumValuesFromObject(arg);\n        }\n        Object.freeze(this.enumValues);\n        this[INITIALIZED] = true;\n        return this;\n    }\n\n    static _enumValuesFromArray(arr) {\n        for (let key of arr) {\n            this._pushEnumValue(new this(), key);\n        }\n    }\n\n    static _enumValuesFromObject(obj) {\n        for (let key of Object.keys(obj)) {\n            let value = new this(obj[key]);\n            this._pushEnumValue(value, key);\n        }\n    }\n\n    static _pushEnumValue(enumValue, name) {\n        enumValue.name = name;\n        enumValue.ordinal = this.enumValues.length;\n        Object.defineProperty(this, name, {\n            value: enumValue,\n            configurable: false,\n            writable: false,\n            enumerable: true,\n        });\n        this.enumValues.push(enumValue);\n    }\n\n    /**\n     * Given the name of an enum constant, return its value.\n     */\n    static enumValueOf(name) {\n        return this.enumValues.find(x => x.name === name);\n    }\n\n    /**\n     * Make enum classes iterable\n     */\n    static [Symbol.iterator]() {\n        return this.enumValues[Symbol.iterator]();\n    }\n\n    /**\n     * Default `toString()` method for enum constant.\n     */\n    toString() {\n        return `${this.constructor.name}.${this.name}`;\n    }\n}\n\nexport function copyProperties(target, source) {\n    // Ideally, we’d use Reflect.ownKeys() here,\n    // but I don’t want to depend on a polyfill\n    for (const key of Object.getOwnPropertyNames(source)) {\n        const desc = Object.getOwnPropertyDescriptor(source, key);\n        Object.defineProperty(target, key, desc);\n    }\n    return target;\n}"]}]}