{"remainingRequest":"/mnt/DATA/DEV/JS/flexio-jsrouter/node_modules/babel-loader/lib/index.js??ref--6!/mnt/DATA/DEV/JS/flexio-jsrouter/node_modules/eslint-loader/index.js??ref--5!/mnt/DATA/DEV/JS/flexio-jshelpers/src/objectHelpers.js","dependencies":[{"path":"/mnt/DATA/DEV/JS/flexio-jshelpers/src/objectHelpers.js","mtime":1549891471851},{"path":"/mnt/DATA/DEV/JS/flexio-jsrouter/node_modules/cache-loader/dist/cjs.js","mtime":1549958118441},{"path":"/mnt/DATA/DEV/JS/flexio-jsrouter/node_modules/babel-loader/lib/index.js","mtime":1548754057753},{"path":"/mnt/DATA/DEV/JS/flexio-jsrouter/node_modules/eslint-loader/index.js","mtime":1549372049588}],"contextDependencies":[],"result":["import { isObject, isUndefined } from './is';\n/**\n *\n * @param {Object} object\n * @param {function} callback\n * @return {Object}\n * @function\n * @export\n */\n\nexport var sortObject = (object, callback) => {\n  var arrayTemp = [];\n  var objectTemp = [];\n\n  for (var prop in object) {\n    if (object.hasOwnProperty(prop)) {\n      arrayTemp.push({\n        'key': prop,\n        'value': object[prop]\n      });\n    }\n  }\n\n  arrayTemp.sort((a, b) => {\n    return callback(a, b);\n  });\n  var countOfArray = arrayTemp.length;\n\n  for (var i = 0; i < countOfArray; i++) {\n    objectTemp[arrayTemp[i]['key']] = arrayTemp[i]['value'];\n  }\n\n  return objectTemp;\n};\n/**\n *\n * @param {Object} object\n * @param {filterObjectCallback} callback\n * @return {Object}\n * @function\n * @export\n */\n\nexport var filterObject = (object, callback) => {\n  Object.keys(object).forEach(key => {\n    var value = object[key];\n\n    if (!callback(value, key, object)) {\n      delete object[key];\n    }\n  });\n  return object;\n};\n/**\n * @callback filterObjectCallback\n * @param {*} value\n * @param {string} key\n * @param {Object} object\n * @return {boolean}\n */\n\n/**\n *\n * @param object\n * @return {ReadonlyArray<any>}\n */\n\nexport var deepFreeze = object => {\n  var propNames = Object.getOwnPropertyNames(object);\n  propNames.forEach(name => {\n    var prop = object[name];\n\n    if (typeof prop === 'object' && prop !== null && !Object.isFrozen(prop)) {\n      deepFreeze(prop);\n    }\n  });\n  return Object.freeze(object);\n};\nexport var deepSeal = object => {\n  var propNames = Object.getOwnPropertyNames(object);\n  propNames.forEach(name => {\n    var prop = object[name];\n\n    if (typeof prop === 'object' && prop !== null && !Object.isSealed(prop)) {\n      deepSeal(prop);\n    }\n  });\n  return Object.seal(object);\n};\n/**\n *\n * @param {Object} object\n * @readonly\n * @return {Object}\n * @function\n * @export\n */\n\nexport var deepFreezeSeal = object => {\n  var propNames = Object.getOwnPropertyNames(object);\n  propNames.forEach(name => {\n    var prop = object[name];\n\n    if (typeof prop === 'object' && prop !== null && !Object.isSealed(prop) && !Object.isFrozen(prop)) {\n      deepFreezeSeal(prop);\n    }\n  });\n  return Object.freeze(Object.seal(object));\n};\n/**\n * split a keys and deep check if key exists in an Object\n * @param {*} object\n * @param {string} keys\n * @param {string} separator\n * @returns {boolean|*}\n */\n\nexport var deepKeyResolver = function deepKeyResolver(object, keys) {\n  var separator = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '.';\n  var arrayKeys = keys.split(separator);\n  var ret = object;\n\n  do {\n    var key = arrayKeys.shift();\n\n    if (key in object) {\n      ret = object[key];\n    } else {\n      return false;\n    }\n  } while (arrayKeys.length);\n\n  return ret;\n};\n/**\n *\n * @param {Object} object\n * @param {string} path\n * @param {*} value\n * @param {string} separator\n */\n\nexport var deepKeyAssigner = function deepKeyAssigner(object, path, value) {\n  var separator = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '.';\n  var pathParts = path.split(separator);\n  var last = path.length;\n\n  if (pathParts.length === 1) {\n    object[path] = value;\n  } else {\n    if (!object[pathParts[0]]) {\n      object[pathParts[0]] = {};\n    }\n\n    var start = pathParts[0].length + 1;\n    var subPath = path.substring(start, last);\n    deepKeyAssigner(object[pathParts[0]], subPath, value, separator);\n  }\n};\nexport var intersectObjectByKey = object => {\n  return Object.keys(object).filter(key => this.storesName.includes(key)).reduce((obj, key) => {\n    obj[key] = object[key];\n    return obj;\n  }, {});\n};\n/**\n *\n * @param {object} object\n * @return {*}\n * @function\n * @export\n */\n\nexport var maxKey = object => {\n  var max;\n\n  for (var key in object) {\n    max = key > max ? key : max;\n  }\n\n  return max;\n};\n/**\n *\n * @param {Object} object\n * @param {Array<String>} properties\n * @returns {boolean}\n * @function\n * @export\n */\n\nexport var hasProperties = (object, properties) => {\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = properties[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var prop = _step.value;\n\n      if (!object.hasOwnProperty(prop)) {\n        return false;\n      }\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return != null) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  return true;\n}; // function deepCopy(obj) {\n//   if (typeof obj === 'object') {\n//     return Object.keys(obj)\n//       .map(k => ({ [k]: deepCopy(obj[k]) }))\n//       .reduce((a, c) => Object.assign(a, c), {})\n//   } else if (Array.isArray(obj)) {\n//     return obj.map(deepCopy)\n//   }\n//   return obj\n// }\n// function deepCopy2(obj) {\n//   if (typeof obj === 'object') {\n//     return Object.getOwnPropertyNames(obj)\n//       .map(k => ({ [k]: deepCopy(obj[k]) }))\n//       .reduce((a, c) => Object.assign(a, c), {})\n//   } else if (Array.isArray(obj)) {\n//     return obj.map(deepCopy)\n//   }\n//   return obj\n// }\n// function clone2(obj) {\n//   if (obj === null || typeof obj !== \"object\") {\n//     return obj;\n//   }\n//   if (obj instanceof Date) {\n//     return new Date(obj.getTime());\n//   }\n//   if (Array.isArray(obj)) {\n//     var clonedArr = [];\n//     obj.forEach(function (element) {\n//       clonedArr.push(clone2(element))\n//     })\n//     return clonedArr\n//   }\n//   let clonedObj = new obj.constructor()\n//   for (var prop in obj) {\n//     if (obj.hasOwnProperty(prop)) {\n//       clonedObj[prop] = clone2(obj[prop])\n//     }\n//   }\n//   return clonedObj\n// }\n// function recursive(obj) {\n//   var clone, i;\n//   if (typeof obj !== 'object' || !obj)\n//     return obj;\n//   if ('[object Array]' === Object.prototype.toString.apply(obj)) {\n//     clone = [];\n//     var len = obj.length;\n//     for (i = 0; i < len; i++)\n//       clone[i] = recursive(obj[i]);\n//     return clone;\n//   }\n//   clone = {};\n//   for (i in obj)\n//     if (obj.hasOwnProperty(i))\n//       clone[i] = recursive(obj[i]);\n//   return clone;\n// }\n\nexport var cloneObject = function cloneObject(object) {\n  var parseDate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  return cloneWithJsonMethod(object, parseDate);\n};\nexport var cloneWithJsonMethod = function cloneWithJsonMethod(object) {\n  var parseDate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n  if (parseDate) {\n    var dateFormat = /^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}.\\d{3}Z$/;\n    return JSON.parse(JSON.stringify(object), (key, value) => {\n      if (dateFormat.test(value)) {\n        return new Date(value);\n      }\n\n      return value;\n    });\n  } else {\n    return JSON.parse(JSON.stringify(object));\n  }\n};\n/**\n *\n * @param {Object} target\n * @param {...Object} sources\n * @return {Object}\n * @function\n * @export\n */\n\nexport var mergeWithoutPrototype = function mergeWithoutPrototype(target) {\n  for (var _len = arguments.length, sources = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    sources[_key - 1] = arguments[_key];\n  }\n\n  return Object.assign(target, ...sources);\n};\n/**\n *\n * @param {object} target\n * @param {object} source\n * @return {object} target\n * @function\n * @export\n */\n\nexport var deepMerge = (target, source) => {\n  for (var k in source) {\n    var sourceValue = source[k];\n    var targetValue = target[k];\n\n    if (isObject(sourceValue)) {\n      target[k] = !isUndefined(targetValue) ? deepMerge(isObject(targetValue) ? targetValue : {}, cloneWithJsonMethod(sourceValue)) : cloneWithJsonMethod(sourceValue);\n    } else if (Array.isArray(sourceValue)) {\n      target[k] = Array.isArray(targetValue) ? [...new Set(targetValue.concat(cloneWithJsonMethod(sourceValue)))] : cloneWithJsonMethod(sourceValue);\n    } else {\n      target[k] = sourceValue;\n    }\n  }\n\n  return target;\n};\n/**\n *\n * @param {Object} input\n * @param {array<string>} keys\n * @param {any} [defaultReturn=null]\n * @return {*}\n */\n\nexport var valueByKeys = function valueByKeys(input, keys) {\n  var defaultReturn = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n  if (keys.length && typeof input !== 'undefined') {\n    var v = input[keys.shift()];\n    return typeof v !== 'undefined' ? valueByKeys(v, keys, defaultReturn) : defaultReturn;\n  }\n\n  return input;\n};",{"version":3,"sources":["/mnt/DATA/DEV/JS/flexio-jshelpers/src/objectHelpers.js"],"names":["isObject","isUndefined","sortObject","object","callback","arrayTemp","objectTemp","prop","hasOwnProperty","push","sort","a","b","countOfArray","length","i","filterObject","Object","keys","forEach","key","value","deepFreeze","propNames","getOwnPropertyNames","name","isFrozen","freeze","deepSeal","isSealed","seal","deepFreezeSeal","deepKeyResolver","separator","arrayKeys","split","ret","shift","deepKeyAssigner","path","pathParts","last","start","subPath","substring","intersectObjectByKey","filter","storesName","includes","reduce","obj","maxKey","max","hasProperties","properties","cloneObject","parseDate","cloneWithJsonMethod","dateFormat","JSON","parse","stringify","test","Date","mergeWithoutPrototype","target","sources","assign","deepMerge","source","k","sourceValue","targetValue","Array","isArray","Set","concat","valueByKeys","input","defaultReturn","v"],"mappings":"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","sourcesContent":["import {\n  isObject,\n  isUndefined\n} from './is'\n\n/**\n *\n * @param {Object} object\n * @param {function} callback\n * @return {Object}\n * @function\n * @export\n */\nexport const sortObject = (object, callback) => {\n  var arrayTemp = []\n  var objectTemp = []\n  for (let prop in object) {\n    if (object.hasOwnProperty(prop)) {\n      arrayTemp.push({\n        'key': prop,\n        'value': object[prop]\n      })\n    }\n  }\n  arrayTemp.sort((a, b) => {\n    return callback(a, b)\n  })\n  let countOfArray = arrayTemp.length\n  for (let i = 0; i < countOfArray; i++) {\n    objectTemp[arrayTemp[i]['key']] = arrayTemp[i]['value']\n  }\n  return objectTemp\n}\n/**\n *\n * @param {Object} object\n * @param {filterObjectCallback} callback\n * @return {Object}\n * @function\n * @export\n */\nexport const filterObject = (object, callback) => {\n  Object.keys(object).forEach((key) => {\n    const value = object[key]\n    if (!callback(value, key, object)) {\n      delete object[key]\n    }\n  })\n  return object\n}\n/**\n * @callback filterObjectCallback\n * @param {*} value\n * @param {string} key\n * @param {Object} object\n * @return {boolean}\n */\n\n/**\n *\n * @param object\n * @return {ReadonlyArray<any>}\n */\nexport const deepFreeze = (object) => {\n  let propNames = Object.getOwnPropertyNames(object)\n  propNames.forEach((name) => {\n    var prop = object[name]\n    if (typeof prop === 'object' && prop !== null && !Object.isFrozen(prop)) {\n      deepFreeze(prop)\n    }\n  })\n  return Object.freeze(object)\n}\nexport const deepSeal = (object) => {\n  let propNames = Object.getOwnPropertyNames(object)\n  propNames.forEach((name) => {\n    var prop = object[name]\n    if (typeof prop === 'object' && prop !== null && !Object.isSealed(prop)) {\n      deepSeal(prop)\n    }\n  })\n  return Object.seal(object)\n}\n/**\n *\n * @param {Object} object\n * @readonly\n * @return {Object}\n * @function\n * @export\n */\nexport const deepFreezeSeal = (object) => {\n  let propNames = Object.getOwnPropertyNames(object)\n  propNames.forEach((name) => {\n    var prop = object[name]\n    if (typeof prop === 'object' && prop !== null && !Object.isSealed(prop) && !Object.isFrozen(prop)) {\n      deepFreezeSeal(prop)\n    }\n  })\n  return Object.freeze(Object.seal(object))\n}\n\n/**\n * split a keys and deep check if key exists in an Object\n * @param {*} object\n * @param {string} keys\n * @param {string} separator\n * @returns {boolean|*}\n */\nexport const deepKeyResolver = (object, keys, separator = '.') => {\n  var arrayKeys = keys.split(separator)\n  var ret = object\n  do {\n    var key = arrayKeys.shift()\n    if (key in object) {\n      ret = object[key]\n    } else {\n      return false\n    }\n  } while (arrayKeys.length)\n  return ret\n}\n\n/**\n *\n * @param {Object} object\n * @param {string} path\n * @param {*} value\n * @param {string} separator\n */\nexport const deepKeyAssigner = (object, path, value, separator = '.') => {\n  var pathParts = path.split(separator)\n  var last = path.length\n\n  if (pathParts.length === 1) {\n    object[path] = value\n  } else {\n    if (!object[pathParts[0]]) {\n      object[pathParts[0]] = {}\n    }\n    var start = pathParts[0].length + 1\n    let subPath = path.substring(start, last)\n    deepKeyAssigner(object[pathParts[0]], subPath, value, separator)\n  }\n}\n\nexport const intersectObjectByKey = (object) => {\n  return Object.keys(object)\n    .filter(key => this.storesName.includes(key))\n    .reduce((obj, key) => {\n      obj[key] = object[key]\n      return obj\n    }, {})\n}\n\n/**\n *\n * @param {object} object\n * @return {*}\n * @function\n * @export\n */\nexport const maxKey = (object) => {\n  var max\n  for (const key in object) {\n    max = (key > max) ? key : max\n  }\n  return max\n}\n\n/**\n *\n * @param {Object} object\n * @param {Array<String>} properties\n * @returns {boolean}\n * @function\n * @export\n */\nexport const hasProperties = (object, properties) => {\n  for (const prop of properties) {\n    if (!object.hasOwnProperty(prop)) {\n      return false\n    }\n  }\n  return true\n}\n\n// function deepCopy(obj) {\n//   if (typeof obj === 'object') {\n//     return Object.keys(obj)\n//       .map(k => ({ [k]: deepCopy(obj[k]) }))\n//       .reduce((a, c) => Object.assign(a, c), {})\n//   } else if (Array.isArray(obj)) {\n//     return obj.map(deepCopy)\n//   }\n//   return obj\n// }\n\n// function deepCopy2(obj) {\n//   if (typeof obj === 'object') {\n//     return Object.getOwnPropertyNames(obj)\n//       .map(k => ({ [k]: deepCopy(obj[k]) }))\n//       .reduce((a, c) => Object.assign(a, c), {})\n//   } else if (Array.isArray(obj)) {\n//     return obj.map(deepCopy)\n//   }\n//   return obj\n// }\n\n// function clone2(obj) {\n//   if (obj === null || typeof obj !== \"object\") {\n//     return obj;\n//   }\n//   if (obj instanceof Date) {\n//     return new Date(obj.getTime());\n//   }\n//   if (Array.isArray(obj)) {\n//     var clonedArr = [];\n//     obj.forEach(function (element) {\n//       clonedArr.push(clone2(element))\n//     })\n//     return clonedArr\n//   }\n\n//   let clonedObj = new obj.constructor()\n//   for (var prop in obj) {\n//     if (obj.hasOwnProperty(prop)) {\n//       clonedObj[prop] = clone2(obj[prop])\n//     }\n//   }\n//   return clonedObj\n// }\n// function recursive(obj) {\n//   var clone, i;\n\n//   if (typeof obj !== 'object' || !obj)\n//     return obj;\n\n//   if ('[object Array]' === Object.prototype.toString.apply(obj)) {\n//     clone = [];\n//     var len = obj.length;\n//     for (i = 0; i < len; i++)\n//       clone[i] = recursive(obj[i]);\n//     return clone;\n//   }\n\n//   clone = {};\n//   for (i in obj)\n//     if (obj.hasOwnProperty(i))\n//       clone[i] = recursive(obj[i]);\n//   return clone;\n// }\n\nexport const cloneObject = (object, parseDate = false) => cloneWithJsonMethod(object, parseDate)\n\nexport const cloneWithJsonMethod = (object, parseDate = false) => {\n  if (parseDate) {\n    const dateFormat = /^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}.\\d{3}Z$/\n    return JSON.parse(JSON.stringify(object), (key, value) => {\n      if (dateFormat.test(value)) {\n        return new Date(value)\n      }\n\n      return value\n    })\n  } else {\n    return JSON.parse(JSON.stringify(object))\n  }\n}\n\n/**\n *\n * @param {Object} target\n * @param {...Object} sources\n * @return {Object}\n * @function\n * @export\n */\nexport const mergeWithoutPrototype = (target, ...sources) => {\n  return Object.assign(target, ...sources)\n}\n\n/**\n *\n * @param {object} target\n * @param {object} source\n * @return {object} target\n * @function\n * @export\n */\nexport const deepMerge = (target, source) => {\n  for (let k in source) {\n    const sourceValue = source[k]\n    const targetValue = target[k]\n\n    if (isObject(sourceValue)) {\n      target[k] = (!isUndefined(targetValue)) ? deepMerge(isObject(targetValue) ? targetValue : {}, cloneWithJsonMethod(sourceValue)) : cloneWithJsonMethod(sourceValue)\n    } else if (Array.isArray(sourceValue)) {\n      target[k] = (Array.isArray(targetValue)) ? [...new Set(targetValue.concat(cloneWithJsonMethod(sourceValue)))] : cloneWithJsonMethod(sourceValue)\n    } else {\n      target[k] = sourceValue\n    }\n  }\n\n  return target\n}\n\n/**\n *\n * @param {Object} input\n * @param {array<string>} keys\n * @param {any} [defaultReturn=null]\n * @return {*}\n */\nexport const valueByKeys = (input, keys, defaultReturn = null) => {\n  if (keys.length && typeof input !== 'undefined') {\n    const v = input[keys.shift()]\n    return (typeof v !== 'undefined') ? valueByKeys(v, keys, defaultReturn) : defaultReturn\n  }\n  return input\n}\n"]}]}